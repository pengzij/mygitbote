[![cakJPA.png](https://z3.ax1x.com/2021/04/10/cakJPA.png)](https://imgtu.com/i/cakJPA)   
单源就是 一个点到另一个点，多源就是多个点到多个点。  其中n表示点的个数，m表示存在的边的个数。因此 如果是稠密图（m ~ n^2），使用朴素Dijkstra算法，如果是稀疏图（m ~ n）使用堆优化的Djikstra算法.

算法题目的难点在于 如何把题目抽象成最短路问题，如何建立点和边

1. 朴素Dijkstra算法（边数大于点数）：  
    1. dist[1] = 0, dist[i] = M;//初始化距离，第一个点的距离为0，其他为无穷大（用一个较大的数表示即可）  
    2. 定义s[i] 为当前已经确定最短距离的点，for i : 1 - n 迭代，t <- 不在s中的，距离最短的点。然后用t更新其他点的距离
    3. 因为是稠密图 用邻接矩阵存储图

2. 堆优化的Djikstra算法（点数大于边数）： 
    1. 一般采用优先队列(priority_queue)来实现堆的数据结构。
    2. 优化的方式是通过小根堆的特性直接找到最小的距离点s[i]，然后根据该点的最小距离更新距离，然后通过把更新的点和对饮的距离插入堆，然后再循环pop（），然后再更新。这种方式实现算法。但是这样堆中最后存储的数据量会有很多重复的冗余，因此程序需要判断。
    3. 因为是稀疏图用邻接表存储图
3. Bellman-ford算法，如下图：
    1. 用于求存在负权边的情况。
    2. 遍历n次，其中每次中遍历所有的边，每次计算dis[b] = min(dis[b],dis[a] + w[i]);
    3. 如果图中出现负权自环可能会没有最短边，如果自环的总权值为负数，那会发生自环死循环。 
    4. 通常直接使用结构体来存储边和权重
    5. ## 如果题目要求有边数限制的最短路，就只能用该方法 ##
    
[![cwlriq.png](https://z3.ax1x.com/2021/04/11/cwlriq.png)](https://imgtu.com/i/cwlriq)

4. spfa算法（一般情况都用这种）：
    1. spfa其实是bellman-ford算法的优化版本。
    2. 先把1入队，然后循环把队头拿出为t，更新t的所有出边，然后把发生更新的点再入队（如果已经存在，就忽略）。
    3. spfa算法很多时候可以做Djikstra算法的题目。速度可能更快。

[![cwvHds.png](https://z3.ax1x.com/2021/04/11/cwvHds.png)](https://imgtu.com/i/cwvHds)

5. floyd算法：
    1. d[i,j]就是i指向j的边。
    2. 可以处理负权，但是不能存在负权回路
    


[![cBFptg.png](https://z3.ax1x.com/2021/04/12/cBFptg.png)](https://imgtu.com/i/cBFptg)